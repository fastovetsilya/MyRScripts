#  assess the risk of investments.
library('forecast')
Data <- read.csv('LSTM_Predicted.csv', header = FALSE)
D_r <- as.data.frame(Data[1:(nrow(Data)-15),])
Nsteps <- 15
Max_params <- 5
D <- NA # 1 or NA
Crit <- 'aic'
Crit_point_1 <- 214
Crit_point_2- 211
ptm <- proc.time()
Custom_arima <- function(Data, Max_params, D)
{
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
return(fit_arima)
}
arima_test <- Custom_arima(D_r, Max_params, D)
arima_predict <- Custom_arima(Data, Max_params, D)
forecast_arimatest <- forecast(arima_test, h = Nsteps)
forecast_arimapredict <- forecast(arima_predict, h = Nsteps)
plot(forecast_arimatest,
xlim = c(100, nrow(Data)+Nsteps))
lines(Data)
plot(forecast_arimapredict,
xlim = c(100, nrow(Data)+Nsteps))
abline(h = Crit_point_1, col = 'green')
abline(h = Crit_point_2, col = 'red')
proc.time() - ptm
#fit_nnetar <- nnetar(D_r)
#plot(forecast(fit_nnetar, h = 100))
# //This tool is currently under development//
# This algorithm uses ARIMA to predict time series data. The hyperparameters
#  of ARIMA are computed by exhaustive search and thus take some time.
# The algorithm may be employed to predict stock market data (prices etc.).
# One of my ideas is to apply this automatic ARIMA model to the representation
#  of the time series obtained from LSTM (see MyPythonScripts). By doing
#  that we eliminate the influence of stochastic processes in the market
#  on the final prediction. The advantage of using ARIMA here is that it
#  1) simple and 2) it calculates confidence bounds of the prediction to
#  assess the risk of investments.
library('forecast')
Data <- read.csv('LSTM_Predicted.csv', header = FALSE)
D_r <- as.data.frame(Data[1:(nrow(Data)-15),])
Nsteps <- 15
Max_params <- 5
D <- NA # 1 or NA
Crit <- 'aic'
Crit_point_1 <- 214
Crit_point_2 <- 211
ptm <- proc.time()
Custom_arima <- function(Data, Max_params, D)
{
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
return(fit_arima)
}
arima_test <- Custom_arima(D_r, Max_params, D)
arima_predict <- Custom_arima(Data, Max_params, D)
forecast_arimatest <- forecast(arima_test, h = Nsteps)
forecast_arimapredict <- forecast(arima_predict, h = Nsteps)
plot(forecast_arimatest,
xlim = c(100, nrow(Data)+Nsteps))
lines(Data)
plot(forecast_arimapredict,
xlim = c(100, nrow(Data)+Nsteps))
abline(h = Crit_point_1, col = 'green')
abline(h = Crit_point_2, col = 'red')
proc.time() - ptm
#fit_nnetar <- nnetar(D_r)
#plot(forecast(fit_nnetar, h = 100))
forecast_arimapredict
View(forecast_arimapredict)
forecast_arimapredict$level
forecast_arimapredict$lower
forecast_arimapredict$lower[2]
forecast_arimapredict$lower[,2]
Lower <- as.numeric(forecast_arimapredict$lower[,2])
Lower < Crit_point_1
Lower[Lower < Crit_point_1]
sum(Crit_point_1 - Lower[Lower < Crit_point_1])
Crit_point_1
Crit_point_1 - Lower[Lower < Crit_point_1]
as.numeric(forecast_arimapredict$upper[,2])
sum(Upper-Lower)
Upper <- as.numeric(forecast_arimapredict$upper[,2])
sum(Upper-Lower)
sum(Crit_point_1 - Lower[Lower < Crit_point_1])
Crit_1_risk <- (sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100
print(paste0('Risk of Crit_point_1 is: ', Crit_1_risk, '%'))
Crit_1_risk <- signif((sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100, 4)
# //This tool is currently under development//
# This algorithm uses ARIMA to predict time series data. The hyperparameters
#  of ARIMA are computed by exhaustive search and thus take some time.
# The algorithm may be employed to predict stock market data (prices etc.).
# One of my ideas is to apply this automatic ARIMA model to the representation
#  of the time series obtained from LSTM (see MyPythonScripts). By doing
#  that we eliminate the influence of stochastic processes in the market
#  on the final prediction. The advantage of using ARIMA here is that it
#  1) simple and 2) it calculates confidence bounds of the prediction to
#  assess the risk of investments.
library('forecast')
Data <- read.csv('LSTM_Predicted.csv', header = FALSE)
D_r <- as.data.frame(Data[1:(nrow(Data)-15),])
Nsteps <- 15
Max_params <- 5
D <- NA # 1 or NA
Crit <- 'aic'
Crit_point_1 <- 214
Crit_point_2 <- 211
ptm <- proc.time()
Custom_arima <- function(Data, Max_params, D)
{
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
return(fit_arima)
}
arima_test <- Custom_arima(D_r, Max_params, D)
arima_predict <- Custom_arima(Data, Max_params, D)
forecast_arimatest <- forecast(arima_test, h = Nsteps)
forecast_arimapredict <- forecast(arima_predict, h = Nsteps)
plot(forecast_arimatest,
xlim = c(100, nrow(Data)+Nsteps))
lines(Data)
plot(forecast_arimapredict,
xlim = c(100, nrow(Data)+Nsteps))
abline(h = Crit_point_1, col = 'green')
abline(h = Crit_point_2, col = 'red')
Lower <- as.numeric(forecast_arimapredict$lower[,2])
Upper <- as.numeric(forecast_arimapredict$upper[,2])
Crit_1_risk <- signif((sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100, 4)
Crit_2_risk <- signif((sum(Crit_point_2 - Lower[Lower < Crit_point_2])/
sum(Upper-Lower)) * 100, 4)
print(paste0('Risk of Crit_point_1 is: ', Crit_1_risk, ' %'))
print(paste0('Risk of Crit_point_2 is: ', Crit_2_risk, ' %'))
proc.time() - ptm
#fit_nnetar <- nnetar(D_r)
#plot(forecast(fit_nnetar, h = 100))
# //This tool is currently under development//
# This algorithm uses ARIMA to predict time series data. The hyperparameters
#  of ARIMA are computed by exhaustive search and thus take some time.
# The algorithm may be employed to predict stock market data (prices etc.).
# One of my ideas is to apply this automatic ARIMA model to the representation
#  of the time series obtained from LSTM (see MyPythonScripts). By doing
#  that we eliminate the influence of stochastic processes in the market
#  on the final prediction. The advantage of using ARIMA here is that it
#  1) simple and 2) it calculates confidence bounds of the prediction to
#  assess the risk of investments.
library('forecast')
Data <- read.csv('LSTM_Predicted.csv', header = FALSE)
D_r <- as.data.frame(Data[1:(nrow(Data)-15),])
Nsteps <- 15
Max_params <- 5
D <- NA # 1 or NA
Crit <- 'aic'
Crit_point_1 <- 214
Crit_point_2 <- 211
ptm <- proc.time()
Custom_arima <- function(Data, Max_params, D)
{
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
<<<<<<< HEAD
return(fit_arima)
}
arima_test <- Custom_arima(D_r, Max_params, D)
arima_predict <- Custom_arima(Data, Max_params, D)
forecast_arimatest <- forecast(arima_test, h = Nsteps)
forecast_arimapredict <- forecast(arima_predict, h = Nsteps)
plot(forecast_arimatest,
xlim = c(100, nrow(Data)+Nsteps))
lines(Data)
plot(forecast_arimapredict,
xlim = c(100, nrow(Data)+Nsteps))
abline(h = Crit_point_1, col = 'green')
abline(h = Crit_point_2, col = 'red')
Lower <- as.numeric(forecast_arimapredict$lower[,2])
Upper <- as.numeric(forecast_arimapredict$upper[,2])
Crit_1_risk <- signif((sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100, 4)
Crit_2_risk <- signif((sum(Crit_point_2 - Lower[Lower < Crit_point_2])/
sum(Upper-Lower)) * 100, 4)
proc.time() - ptm
print(paste0('Risk of Crit_point_1 is: ', Crit_1_risk, ' %'))
print(paste0('Risk of Crit_point_2 is: ', Crit_2_risk, ' %'))
#fit_nnetar <- nnetar(D_r)
#plot(forecast(fit_nnetar, h = 100))
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
=======
plot(forecast(fit_arima, h = 100), xlim = c(220, nrow(Data)+20),
ylim = c(40, 60))
fit_nnetar <- nnetar(Data[,1], size=20, repeats = 20)
plot(forecast(fit_nnetar, h = 100))
plot(forecast(fit_arima, h = 100), xlim = c(220, nrow(Data)+20),
ylim = c(20, 60))
plot(forecast(fit_arima, h = 100), xlim = c(220, nrow(Data)+20),
ylim = c(30, 40))
# This tool is currently under development
library('forecast')
Data <- read.csv('LSTM_Predicted.csv')
Max_params <- 10
fit_arima <- auto.arima(Data, d = NA, D = NA, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = FALSE, ic = 'aic', stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
plot(forecast(fit_arima, h = 100), xlim = c(220, nrow(Data)+20),
ylim = c(40, 60))
fit_nnetar <- nnetar(Data[,1], size=20, repeats = 20)
plot(forecast(fit_nnetar, h = 100))
plot(forecast(fit_arima, h = 100), xlim = c(220, nrow(Data)+20),
ylim = c(20, 60))
plot(forecast(fit_arima, h = 100), xlim = c(220, nrow(Data)+20),
ylim = c(20, 50))
plot(forecast(fit_arima, h = 100), xlim = c(220, nrow(Data)+20),
ylim = c(25, 45))
plot(forecast(fit_arima, h = 100), xlim = c(220, nrow(Data)+20),
ylim = c(30, 45))
plot(forecast(fit_arima, h = 100), xlim = c(210, nrow(Data)+20),
ylim = c(30, 45))
plot(forecast(fit_nnetar, h = 30))
# This tool is currently under development
library('forecast')
Data <- read.csv('LSTM_Predicted.csv')
Max_params <- 10
fit_arima <- auto.arima(Data, d = NA, D = NA, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = FALSE, ic = 'aic', stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
plot(forecast(fit_arima, h = 100), xlim = c(210, nrow(Data)+20),
ylim = c(30, 45))
fit_nnetar <- nnetar(Data[,1], size=20, repeats = 20)
plot(forecast(fit_nnetar, h = 30))
plot(forecast(fit_arima, h = 100), xlim = c(210, nrow(Data)+20),
ylim = c(220, 240))
plot(forecast(fit_arima, h = 100), xlim = c(210, nrow(Data)+20),
ylim = c(200, 260))
>>>>>>> 72f2edbf36e4135ff9678a48629b58b07d4e1108
# //This tool is currently under development//
# This algorithm uses ARIMA to predict time series data. The hyperparameters
#  of ARIMA are computed by exhaustive search and thus take some time.
# The algorithm may be employed to predict stock market data (prices etc.).
# One of my ideas is to apply this automatic ARIMA model to the representation
#  of the time series obtained from LSTM (see MyPythonScripts). By doing
#  that we eliminate the influence of stochastic processes in the market
#  on the final prediction. The advantage of using ARIMA here is that it
#  1) simple and 2) it calculates confidence bounds of the prediction to
#  assess the risk of investments.
library('forecast')
Data <- read.csv('LSTM_Predicted.csv', header = FALSE)
D_r <- as.data.frame(Data[1:(nrow(Data)-15),])
Nsteps <- 15
Max_params <- 5
D <- NA # 1 or NA
Crit <- 'aic' # 'aic', 'bic', or 'aicc'
Crit_point_1 <- 214
Crit_point_2 <- 211
ptm <- proc.time()
Custom_arima <- function(Data, Max_params, D)
{
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE,
seasonal = FALSE, ic = 'aic', stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
return(fit_arima)
}
arima_test <- Custom_arima(D_r, Max_params, D)
arima_predict <- Custom_arima(Data, Max_params, D)
forecast_arimatest <- forecast(arima_test, h = Nsteps)
forecast_arimapredict <- forecast(arima_predict, h = Nsteps)
plot(forecast_arimatest,
xlim = c(100, nrow(Data)+Nsteps))
lines(Data)
plot(forecast_arimapredict,
xlim = c(100, nrow(Data)+Nsteps))
abline(h = Crit_point_1, col = 'green')
abline(h = Crit_point_2, col = 'red')
Lower <- as.numeric(forecast_arimapredict$lower[,2])
Upper <- as.numeric(forecast_arimapredict$upper[,2])
Crit_1_risk <- signif((sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100, 4)
Crit_2_risk <- signif((sum(Crit_point_2 - Lower[Lower < Crit_point_2])/
sum(Upper-Lower)) * 100, 4)
print(proc.time() - ptm)
print(paste0('Risk of Crit_point_1 is: ', Crit_1_risk, ' %'))
print(paste0('Risk of Crit_point_2 is: ', Crit_2_risk, ' %'))
plot(forecast(fit_arima, h = 100), xlim = c(210, nrow(Data)+20),
ylim = c(200, 260))
fit_nnetar <- nnetar(Data[,1], size=20, repeats = 20)
plot(forecast(fit_nnetar, h = 30))
# //This tool is currently under development//
# This algorithm uses ARIMA to predict time series data. The hyperparameters
#  of ARIMA are computed by exhaustive search and thus take some time.
# The algorithm may be employed to predict stock market data (prices etc.).
# One of my ideas is to apply this automatic ARIMA model to the representation
#  of the time series obtained from LSTM (see MyPythonScripts). By doing
#  that we eliminate the influence of stochastic processes in the market
#  on the final prediction. The advantage of using ARIMA here is that it
#  1) simple and 2) it calculates confidence bounds of the prediction to
#  assess the risk of investments.
library('forecast')
Data <- read.csv('LSTM_Predicted.csv', header = FALSE)
D_r <- as.data.frame(Data[1:(nrow(Data)-15),])
Nsteps <- 15
Max_params <- 5
D <- NA # 1 or NA
Crit <- 'aic' # 'aic', 'bic', or 'aicc'
Crit_point_1 <- 214
Crit_point_2 <- 211
ptm <- proc.time()
Custom_arima <- function(Data, Max_params, D)
{
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE,
seasonal = FALSE, ic = 'aic', stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
return(fit_arima)
}
arima_test <- Custom_arima(D_r, Max_params, D)
arima_predict <- Custom_arima(Data, Max_params, D)
forecast_arimatest <- forecast(arima_test, h = Nsteps)
forecast_arimapredict <- forecast(arima_predict, h = Nsteps)
plot(forecast_arimatest,
xlim = c(100, nrow(Data)+Nsteps))
lines(Data)
plot(forecast_arimapredict,
xlim = c(100, nrow(Data)+Nsteps))
abline(h = Crit_point_1, col = 'green')
abline(h = Crit_point_2, col = 'red')
Lower <- as.numeric(forecast_arimapredict$lower[,2])
Upper <- as.numeric(forecast_arimapredict$upper[,2])
Crit_1_risk <- signif((sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100, 4)
Crit_2_risk <- signif((sum(Crit_point_2 - Lower[Lower < Crit_point_2])/
sum(Upper-Lower)) * 100, 4)
print(proc.time() - ptm)
print(paste0('Risk of Crit_point_1 is: ', Crit_1_risk, ' %'))
print(paste0('Risk of Crit_point_2 is: ', Crit_2_risk, ' %'))
Crit_1_risk <- signif((sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100, 4)
Lower <- as.numeric(forecast_arimapredict$lower[,2])
Data <- read.csv('LSTM_Predicted.csv', header = FALSE)
View(Data)
library('forecast')
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE, ic = 'aic',
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
# //This tool is currently under development//
# This algorithm uses ARIMA to predict time series data. The hyperparameters
#  of ARIMA are computed by exhaustive search and thus take some time.
# The algorithm may be employed to predict stock market data (prices etc.).
# One of my ideas is to apply this automatic ARIMA model to the representation
#  of the time series obtained from LSTM (see MyPythonScripts). By doing
#  that we eliminate the influence of stochastic processes in the market
#  on the final prediction. The advantage of using ARIMA here is that it
#  1) simple and 2) it calculates confidence bounds of the prediction to
#  assess the risk of investments.
library('forecast')
Data <- read.csv('LSTM_Predicted.csv', header = FALSE)
D_r <- as.data.frame(Data[1:(nrow(Data)-15),])
Nsteps <- 15
Max_params <- 5
D <- NA # 1 or NA
Crit <- 'aic' # 'aic', 'bic', or 'aicc'
Crit_point_1 <- 214
Crit_point_2 <- 211
ptm <- proc.time()
Custom_arima <- function(Data, Max_params, D)
{
fit_arima <- auto.arima(Data, d = NA, D = D, max.p = Max_params, max.q = Max_params,
max.P = Max_params, max.Q = Max_params, max.order = 50,
max.d = Max_params, max.D = Max_params,
start.p = 1,
start.q = 1, start.P = 1, start.Q = 1, stationary = FALSE,
seasonal = TRUE, ic = Crit, stepwise = FALSE,
trace = TRUE, approximation = FALSE,
truncate = NULL, xreg = NULL, test = 'kpss',
seasonal.test = "ocsb", allowdrift = TRUE, allowmean = TRUE,
lambda = NULL, biasadj = FALSE, parallel = TRUE, num.cores = 2)
return(fit_arima)
}
arima_test <- Custom_arima(D_r, Max_params, D)
arima_predict <- Custom_arima(Data, Max_params, D)
forecast_arimatest <- forecast(arima_test, h = Nsteps)
forecast_arimapredict <- forecast(arima_predict, h = Nsteps)
plot(forecast_arimatest,
xlim = c(100, nrow(Data)+Nsteps))
lines(Data)
plot(forecast_arimapredict,
xlim = c(100, nrow(Data)+Nsteps))
abline(h = Crit_point_1, col = 'green')
abline(h = Crit_point_2, col = 'red')
Lower <- as.numeric(forecast_arimapredict$lower[,2])
Upper <- as.numeric(forecast_arimapredict$upper[,2])
Crit_1_risk <- signif((sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100, 4)
Crit_2_risk <- signif((sum(Crit_point_2 - Lower[Lower < Crit_point_2])/
sum(Upper-Lower)) * 100, 4)
print(proc.time() - ptm)
print(paste0('Risk of Crit_point_1 is: ', Crit_1_risk, ' %'))
print(paste0('Risk of Crit_point_2 is: ', Crit_2_risk, ' %'))
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
Max_params <- 5
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
source('~/My Scripts repo/MyRScripts/ARIMA/ARIMA.R')
Crit_point_1 <- 36
Crit_point_2 <- 35
Crit_1_risk <- signif((sum(Crit_point_1 - Lower[Lower < Crit_point_1])/
sum(Upper-Lower)) * 100, 4)
Crit_2_risk <- signif((sum(Crit_point_2 - Lower[Lower < Crit_point_2])/
sum(Upper-Lower)) * 100, 4)
print(proc.time() - ptm)
print(paste0('Risk of Crit_point_1 is: ', Crit_1_risk, ' %'))
print(paste0('Risk of Crit_point_2 is: ', Crit_2_risk, ' %'))
function (x, as.factor = FALSE)
{
if (as.factor) {
labs <- colnames(x, do.NULL = FALSE, prefix = "")
res <- factor(.Internal(col(dim(x))), labels = labs)
dim(res) <- dim(x)
res
}
else .Internal(col(dim(x)))
}
abline(h = Crit_point_1, col = 'green')
abline(h = Crit_point_2, col = 'red')
print(paste0('Risk of Crit_point_1 is: ', Crit_1_risk, ' %'))
print(paste0('Risk of Crit_point_2 is: ', Crit_2_risk, ' %'))
